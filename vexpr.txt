●概要
    変数操作の対象およびオペランドの項目として追加予定の「式」についての説明です
    
    入力はテキスト形式でおこなわれますが、エディタでテキストをバイトコードに変換してから保持します
    そのため入力内容は常に整形されています
    定数畳み込みなどの最適化はありません
    
    評価は　対象変数の式→オペランドの式　の順です
    変数操作コマンドの仕様上、
    対象が範囲の場合はそれぞれへの操作に対してオペランドが毎回評価されるため注意が必要です
    ※式中では範囲対象に代入の際も右辺評価は1度だけです
    
    ほかで代用可能な式は専用のオペランドのほうが高速です
    例えば「v[1] = a + b」なら二項演算の「add(a, b)」に置き換えたほうが良い結果を得られます

    
●数値
    10進数または16進数(接頭辞0x)表記が可能です
    桁の区切りとしてアンダーバーが使用できますが、この情報は保存されません
    値の有効範囲はマニアクスでの変数値と同じ -2147483648～2147483647 です
    範囲外の定数値は解析時にチェックされません(100000000000などはオーバーフローします)

    (例)
    0, 123, 0xFFFF_FFFF

    

●スイッチ
    s[番号] でスイッチをあらわします
    スイッチの評価は偽(OFF)が0、真(ON)は1になります
    スイッチへの代入は0が偽(OFF)、それ以外は真(ON)になります
    
    式中の代入操作(+=, -= 等も含む)に限り番号は範囲オブジェクト(a..b)での指定が可能です
    ただし、両辺が範囲の場合はともにスイッチである必要があります
    また、両辺が範囲で数に差があるときは左辺に揃えられ、不足分は0が補われます
    
    (例)
    s[1..3] = v[5]                  OK
    s[1..3] = s[5..7]               OK
    s[1..3] = v[5..7]               NG
    s[1..3] = s[5..6]               OK(1～3は s[5], s[6], OFF)
    
    式中の範囲対象への代入操作(+=, -= 等も含む)では右辺に一時配列の指定が可能です
    両辺が範囲/要素数に差があるときは左辺に揃えられ、不足分は0が補われます
    
    (例)
    s[1..3] = [4, v[5], s[2]]       OK(1～3は ON, v[5] != 0, s[2])

    
●変数
    v[番号] で変数をあらわします
    
    式中の代入操作(+=, -= 等も含む)に限り番号は範囲オブジェクト(a..b)での指定が可能です
    ただし、両辺が範囲の場合はともに変数である必要があります
    また、両辺が範囲で数に差があるときは左辺に揃えられ、不足分は0が補われます
    
    (例)
    v[1..3] = s[5]                  OK
    v[1..3] = v[5..7]               OK
    v[1..3] = s[5..7]               NG
    v[1..3] = v[5..6]               OK(1～3は v[5], v[6], 0)

    式中の範囲対象への代入操作(+=, -= 等も含む)では右辺に一時配列の指定が可能です
    両辺が範囲/要素数に差があるときは左辺に揃えられ、不足分は0が補われます
    
    (例)
    v[1..3] = [4, v[5], s[2]]       OK(1～3は 4, v[5], s[2])

    
    
●一時配列
    計算の途中で使うことのできる擬似的な配列です
    [要素1, 要素2, 要素3...]という形式であらわします
    範囲対象の変数/スイッチそれぞれに異なる値を代入したいときなどに使います
    数値が求められる場面での配列の評価は未定義です
    要素には添え字でアクセス可能ですが、その際の戻り値は現行では全て数値で評価されます
    
    (例)
    v[1] = [5, 6, 7][2]             OK(v[1] は 7)
    v[2] = [[5, 6], [7, 8]][1][0]   NG

    
●演算
    2003標準と同じく飽和演算です
    &&や||は短絡評価です
    数値が求められる場面での範囲オブジェクト(a..b)の評価は未定義です


・単項演算
    符号反転(-)
    否定(!)
    ビット反転(~)


・二項演算
    代入(=, +=, -=, *=, /=, %= |=, &=, ^=, <<=, >>=)
    加算(+)
    減算(-)
    乗算(*)
    除算(/)
    剰余(%)
    論理和(|)
    論理積(&)
    排他的論理和(^)
    論理左シフト(<<)
    論理右シフト(>>)
    ～と同じ(==)
    ～より大きい(>)
    ～より小さい(<)
    ～以上(>=)
    ～以下(<=)
    ～以外(!=)
    aまたはb(||)
    aかつb(&&)
    aからb(..)
    
    
・三項演算
    条件 ? 真の場合 : 偽の場合
    

・優先順位(上から高い順)
    括弧, インデックスアクセス
    単項演算
    乗算(*), 除算(/), 剰余(%)
    加算(+), 減算(-)
    論理左シフト(<<), 論理右シフト(>>)
    ～より大きい(>), ～より小さい(<), ～以上(>=), ～以下(<=)
    ～と同じ(==), ～以外(!=)
    論理積(&)
    排他的論理和(^)
    論理和(|)
    aかつb(&&)
    aまたはb(||)
    aからb(..)
    三項演算
    代入(=, +=, -=, *=, /=, %= |=, &=, ^=, <<=, >>=)
  
  
    
●組み込み関数

・rnd(a, b)
    変数操作オペランドの「乱数」と同じです
    aからbの範囲内の乱数を返します


・item(id, type)
    変数操作オペランドの「アイテム」と同じです
    アイテム[id]のtypeを返します


・actor(id, type)
    変数操作オペランドの「主人公」と同じです
    主人公[id]のtypeを返します


・member(idx, type)
    変数操作オペランドの「パーティメンバー」と同じです
    メンバー[idx]のtypeを返します


・event(id, type)
    変数操作オペランドの「イベント」と同じです
    イベント[id]のtypeを返します


・enemy(idx, type)
    変数操作オペランドの「敵キャラ」と同じです
    敵キャラ[idx]のtypeを返します


・misc(type)
    変数操作オペランドの「その他」と同じです
    typeの情報を返します

    ※オペランドの並び順とtypeの値は一致しないことに注意してください


・pow(a, b)
・min(a, b)
・max(a, b)
・abs(a)
    変数操作オペランドの「数学関数」のものと同じです


・sqrt(a, b)
    変数操作オペランドの「数学関数」のものとほぼ同じです
    bは乗数です


・sin(a, b, c)
・cos(a, b, c)
・atan2(a, b, c)
    変数操作オペランドの「数学関数」のものとほぼ同じです
    cは乗数です

    
・clamp(a, b, c)
    aをb～cの範囲で丸めたものを返します
    min(max(a, b), c)と同じです


・muldiv(a, b, c)
    「a * b / c」を符号付き64bit整数で計算し、符号付き32bit整数にして返します

    
・divmul(a, b, c)
    「a / b * c」を倍精度小数で計算し、符号付き32bit整数にして返します

    
・between(a, b, c)
    「a >= b && a <= c」と同じです

    
